#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Game Bird – Hot‑plug manager w/ PID‑based fbcp restart

• EDID‑based HDMI detection (works with hdmi_force_hotplug=1)
• Audio swap via amixer + asound.conf + ~/.asoundrc + runcommand override
• mk_arcade_joystick_rpi enable/disable
• Proper PID‑based restart of fbcp‑ili9341 so SPI never freezes
"""

import os
import signal
import time
import pathlib
import pwd
import shutil
import subprocess as sp
import tempfile
from glob import glob

POLL_DELAY = 2  # seconds
FBCP_CMD   = "/usr/local/bin/fbcp-ili9341"
FBCP_ARGS  = ["-x", "200", "-y", "120", "-w", "240", "-h", "240", "-noscaling"]

# -----------------------------------------------------------------------------
# HDMI detection (EDID)
# -----------------------------------------------------------------------------

def _kms_edid_present() -> bool:
    for edid in glob("/sys/class/drm/card*-HDMI-A-*/edid"):
        try:
            if pathlib.Path(edid).stat().st_size >= 128:
                return True
        except FileNotFoundError:
            pass
    return False


def _legacy_edid_present() -> bool:
    """Fallback for FKMS/DispmanX systems (tvservice). Safe to remove on KMS‑only
    images once you move past Buster.
    """
    with tempfile.NamedTemporaryFile() as tmp:
        try:
            r = sp.run([
                "/usr/bin/tvservice", "-d", tmp.name
            ], stdout=sp.DEVNULL, stderr=sp.DEVNULL, timeout=3)
            if r.returncode == 0 and pathlib.Path(tmp.name).stat().st_size >= 128:
                return True
        except FileNotFoundError:
            pass
    return False


def hdmi_connected() -> bool:
    ok = _kms_edid_present() or _legacy_edid_present()
    print(f"DEBUG: HDMI connected? {ok}")
    return ok

# -----------------------------------------------------------------------------
# Audio swap + runcommand override
# -----------------------------------------------------------------------------

HDMI_CARD, HDMI_VOL_ID, HDMI_SW_ID = "0", "1", "2"
HP_CARD,   HP_VOL_ID,   HP_SW_ID   = "1", "1", "2"
DESIRED_VOL = "250"  # 0–400

ASOUND_DEFAULT = "/etc/asound.conf"
ASOUND_USER    = pathlib.Path(pwd.getpwnam("pi").pw_dir) / ".asoundrc"
ASOUND_HDMI    = "/etc/asound.hdmi.conf"
ASOUND_HP      = "/etc/asound.hp.conf"
RUNCOMMAND_CFG = "/opt/retropie/configs/all/runcommand.cfg"


def _ensure_snippets():
    # Predefined fallback content in case source files go missing
    default_hdmi = "defaults.pcm.card 0\ndefaults.ctl.card 0\n"
    default_hp   = "defaults.pcm.card 1\ndefaults.ctl.card 1\n"

    if not pathlib.Path(ASOUND_HDMI).exists():
        print("[HotPlug] Warning: /etc/asound.hdmi.conf missing, using fallback")
        pathlib.Path("/home/pi/.asound.hdmi.conf").write_text(default_hdmi)
    if not pathlib.Path(ASOUND_HP).exists():
        print("[HotPlug] Warning: /etc/asound.hp.conf missing, using fallback")
        pathlib.Path("/home/pi/.asound.hp.conf").write_text(default_hp)

def _swap_asound(to_hdmi: bool):
    _ensure_snippets()
    src = ASOUND_HDMI if to_hdmi else ASOUND_HP
    for dst in (ASOUND_DEFAULT, ASOUND_USER):
        try:
            p = pathlib.Path(dst)
            if not p.exists() or p.read_bytes() != pathlib.Path(src).read_bytes():
                shutil.copy(src, dst)
        except PermissionError:
            pass
    sp.run(["alsactl", "restore"], stdout=sp.DEVNULL, stderr=sp.DEVNULL)

    # RetroPie runcommand audio_device override
    desired = "hdmi" if to_hdmi else "local"
    try:
        lines = pathlib.Path(RUNCOMMAND_CFG).read_text().splitlines()
    except FileNotFoundError:
        lines = []
    lines = [l for l in lines if not l.startswith("audio_device=")]
    lines.append(f"audio_device={desired}")
    pathlib.Path(RUNCOMMAND_CFG).write_text("\n".join(lines) + "\n")


def _amixer(card: str, numid: str, value: str):
    """Robust amixer helper with up‑to‑three retries."""
    for _ in range(3):
        sp.run(
            ["amixer", "-q", "-c", card, "cset", f"numid={numid}", value],
            stdout=sp.DEVNULL, stderr=sp.DEVNULL
        )
        out = sp.check_output([
            "amixer", "-c", card, "cget", f"numid={numid}"
        ], text=True)
        if value.isdigit():
            if f"values={value}" in out:
                break
        else:
            if f"[{value}]" in out:
                break
        time.sleep(0.1)


def set_audio(to_hdmi: bool):
    if to_hdmi:
        _amixer(HDMI_CARD, HDMI_SW_ID, "1")
        _amixer(HDMI_CARD, HDMI_VOL_ID, DESIRED_VOL)
        _amixer(HP_CARD,   HP_SW_ID,   "0")
        _amixer(HP_CARD,   HP_VOL_ID,  "0")
    else:
        _amixer(HP_CARD,   HP_SW_ID,   "1")
        _amixer(HP_CARD,   HP_VOL_ID,  DESIRED_VOL)
        _amixer(HDMI_CARD, HDMI_SW_ID, "0")
        _amixer(HDMI_CARD, HDMI_VOL_ID, "0")
    _swap_asound(to_hdmi)

# -----------------------------------------------------------------------------
# Joystick HAT toggle
# -----------------------------------------------------------------------------

def hat_loaded() -> bool:
    return pathlib.Path("/sys/module/mk_arcade_joystick_rpi").exists()


def toggle_hat(enable: bool):
    if enable and not hat_loaded():
        sp.call(["modprobe", "mk_arcade_joystick_rpi"])
    elif not enable and hat_loaded():
        sp.call(["modprobe", "-r", "mk_arcade_joystick_rpi"])

# -----------------------------------------------------------------------------
# fbcp restart: PID‑based SIGTERM→wait→SIGKILL→spawn
# -----------------------------------------------------------------------------

def restart_fbcp():
    base = os.path.basename(FBCP_CMD)

    # Find running PIDs
    try:
        out = sp.check_output(["pidof", base], text=True).strip()
        pids = [int(p) for p in out.split()]
    except sp.CalledProcessError:
        pids = []

    # SIGTERM running instances
    for pid in pids:
        try:
            os.kill(pid, signal.SIGTERM)
        except ProcessLookupError:
            pass

    # Wait up to 1 s for graceful exit
    for _ in range(10):
        alive = [pid for pid in pids if os.path.exists(f"/proc/{pid}")]
        if not alive:
            break
        time.sleep(0.1)
    else:
        # Force‑kill survivors
        for pid in alive:
            try:
                os.kill(pid, signal.SIGKILL)
            except ProcessLookupError:
                pass
        time.sleep(0.1)

    # Spawn fresh instance
    sp.Popen([FBCP_CMD] + FBCP_ARGS, stdout=sp.DEVNULL, stderr=sp.DEVNULL)
    time.sleep(0.25)  # give DMA a moment to settle

# -----------------------------------------------------------------------------
# Main loop
# -----------------------------------------------------------------------------

def log(msg: str):
    print(f"[HotPlug] {time.strftime('%Y-%m-%d %H:%M:%S')} | {msg}", flush=True)


def main():
    # Disable legacy service (idempotent)
    sp.run([
        "systemctl", "disable", "--now", "fbcp.service"
    ], stdout=sp.DEVNULL, stderr=sp.DEVNULL, check=False)

    # Start fbcp immediately
    restart_fbcp()

    last_state = None
    while True:
        conn = hdmi_connected()
        if conn != last_state:
            log(f"HDMI {'connected' if conn else 'disconnected'} – reconfiguring")
            set_audio(conn)
            toggle_hat(not conn)
            restart_fbcp()
            last_state = conn
        time.sleep(POLL_DELAY)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
